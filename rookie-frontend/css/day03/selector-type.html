<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN""http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" languages="zh-CN">
<head>
<meta charset="utf-8">
<title>
selector-type
</title>
</head>
<body>
    <p> 后代选择器 >子元素选择器(必须是直接子元素) +相邻元素选择器 ~后续兄弟选择器(如div~p 给同一父元素中 出现在div标签后的兄弟p元素定义样式)</p>
    <h1>伪类与伪元素</h1>
    <p>正常的伪类和配合css类(a.redcolor:visited)使用之前已经练习过 以first-child为例来写几个伪类和组合选择器的例子:<br />
    p:first-child{} 用来匹配 任何第一个子元素为p的p元素; p > i:first-child{} 作用对象为i,用来匹配作为p的第一个子元素为i的i元素; p:first-child i {}作用对象仍然是i, 约束条件是i为p的子元素,且这个p需要是任意元素的第一个子元素 <br />
    
    lang
    
    </p>

    <p>伪元素也可以使用: 但是规范来说还是使用:: 本质上和伪类的不同主要在dom树层面 暂时不关注

        伪类选择元素基于的是当前元素处于的状态，或者说元素当前所具有的特性，而不是元素的id、class、属性等静态的标志。由于状态是动态变化的，所以一个元素达到一个特定状态时，它可能得到一个伪类的样式；当状态改变时，它又会失去这个样式。由此可以看出，它的功能和class有些类似，但它是基于文档之外的抽象，所以叫伪类。

与伪类针对特殊状态的元素不同的是，伪元素是对元素中的特定内容进行操作，它所操作的层次比伪类更深了一层，也因此它的动态性比伪类要低得多。实际上，设计伪元素的目的就是去选取诸如元素内容第一个字（母）、第一行，选取某些内容前面或后面这种普通的选择器无法完成的工作。它控制的内容实际上和元素是相同的，但是它本身只是基于元素的抽象，并不存在于文档中，所以叫伪元素。
    </p>
</body>
</html>